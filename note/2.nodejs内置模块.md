- [url](#url)
  - [log4js](#log4js)
  - [new URL(<url>)](#new-urlurl)
  - [new URLSearchParams(<Params>)](#new-urlsearchparamsparams)
- [querysting](#querysting)
  - [querystring.parse(str[, sep[, eq[, options]]]) && querystring.decode](#querystringparsestr-sep-eq-options--querystringdecode)
  - [querystring.stringify(obj[, sep[, eq[, options]]]) && querysting.encode](#querystringstringifyobj-sep-eq-options--querystingencode)
- [http](#http)
  - [调试工具](#调试工具)
    - [Insomnia](#insomnia)
  - [node进程管理工具](#node进程管理工具)
  - [response](#response)
  - [request](#request)
  - [GET](#get)
  - [POST](#post)
- [CROS](#cros)
  - [jsonp](#jsonp)
  - [CORS](#cors)
  - [middleware(http-proxy-middware)](#middlewarehttp-proxy-middware)
    - [安装](#安装)
  - [爬虫](#爬虫)
# url
## [log4js](https://www.npmjs.com/package/log4js)
通过打印操作，来形成日志，并记录成文件,java也有log4

以下是官方提供的例子
``` javascript
const log4js = require("log4js");
log4js.configure({
  // 定义logger名，输出位置
  appenders: { cheese: { type: "file", filename: "cheese.log" } },
  // 定义输出级别
  categories: { default: { appenders: ["cheese"], level: "error" } }
});

// 对loagger进行赋值，这里获取的是cheese这个logger,对应categories.name 
// 这里其实是获取default，并给别名chesese
const logger = log4js.getLogger("cheese");
// 以下输出级别由低到高，设置的越高能够打印的数量就越少。
logger.trace("Entering cheese testing");
logger.debug("Got cheese.");
logger.info("Cheese is Comté.");
logger.warn("Cheese is quite smelly.");
logger.error("Cheese is too ripe!");
logger.fatal("Cheese was breeding ground for listeria.");
```
## new URL(<url>)
可以获取url对应的各种信息，如protocal,username,password,host...
## new URLSearchParams(<Params>)
可以获取参数，还可以通过.get方法获取某个参数的值
``` javascript
const urlParams = new URLSearchParams(urlStr.searchParams);
logger.info(urlParams.get("id"));
```
# querysting
## querystring.parse(str[, sep[, eq[, options]]]) && querystring.decode
+ sep:标识分割符 默认为&
+ eq：默认为 =
+ options \<object>: 为编码方式
``` javascript
const url = new URL(
  "https://www.bilibili.com/video/BV1ca4y1n7u3?p=16&spm_id_from=pageDriver"
);
// const res = querystring.parse(url.search.slice(1));
const res = querystring.decode(url.search.slice(1)); //返回参数的对象
```
## querystring.stringify(obj[, sep[, eq[, options]]]) && querysting.encode
``` javascript
const parmasStr = querystring.stringify({
  foo: "bar",
  baz: ["qux", "quux"],
  corge: "",
},
});
logger.info(parmasStr); // foo=bar&baz=qux&baz=quux&corge=
// 中文的情况
const parmasStr = querystring.stringify(
  {
    foo: "bar",
    baz: ["东西", "好动西"], //中文会被转化成百分比字符
    corge: "",
  },
  null,
  null,
  {
    //若要获取中文，需要进行百分比编码字符的解码
    encodeURIComponent(string) {
      return querystring.unescape(string);
    },
  }
);
```
# http 
## 调试工具
``` javascript
$ node --inspect-brk server.js
```
在控制台左上角打开调试工具，通过debugger设置断点。
### Insomnia
用于测试接口。似乎还有postman。
## node进程管理工具
+ supervisor
+ nodemon
+ forever
+ pm2
## response
server.js
``` js
const http = require("http");

const server = http.createServer((request, response) => {
  response.writeHead(200, { //控制浏览器显示，
    'content-type': 'text/html' // 解析html
  })
  response.write('<h1>hello node.js http</h1>')
  response.end() // 注意end ，否则一直转
});

server.listen(8000, () => {
  console.log("服务开启端口8000");
});
```
``` js
  response.writeHead(200, { //控制浏览器显示，
    // 'content-type': 'text/plain',  // 解析字符串
    // 'content-type': 'text/html', // 解析html
    'content-type': 'application/json;charset=utf-8' // 解析json,utf-8编码，可以不指定，有默认值
  })
  response.end('{"name": "wuug"}') // 注意end ，否则一直转.若是返回很简单也可以直接在end中返回
```
## request
server.js
``` js
  let data = ''
  request.on('data', (chunk) => {
    data += chunk
  })
  log.info(data) // 这里打印出来是空的，看来request.on将data在其定义域内重新定义了一个
  request.on('end', () => {
          response.writeHead(200, {
      'content-type': 'application/json;charset=urf-8'
    })
    response.end(JSON.stringify(querystirng.parse(data))) // 注意end ，否则一直转.若是返回很简单也可以直接在end中返回
  })
```
## GET
``` js
  https.get('https://g.alicdn.com/tbhome/??taobao-2021/0.0.5/lib/monitor-min.js', (res) => {
    log.debug('statusCode', res.statusCode)
    log.debug('headers', res.headers)
    let data = ''
    res.on('data', (chunk) => {
      data += chunk
    })
    res.on('end', () => {
      response.writeHead(200, {
        'content-type': 'application/json;charset=urf-8'
      })
      response.end(data)
    })
  }).on('error', e => {
    log.error(e)
  })
```
## POST
``` js
const http = require('http')
const querystring = require('querystring')

const postData = querystring.stringify({ //发送的请求,需要转换为json格式
  'msg': 'Hello World!'
});

const options = { //opst 请求的options
  protocol: 'http:',
  hostname: 'localhost',
  method: 'post',
  port: 3000,
  path: '/data',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
    'Content-Length': Buffer.byteLength(postData) //表明发送数据的长度
  }
}
const server = http.createServer((req, res) => {
  const request = http.request(options, (result) => { //这里发送post请求
  })
  request.write(postData) // 写入post请求携带的数据
  request.end() // post 请求结束

  res.end()
})

server.listen(8000, () => {
  console.log('服务8000端口');
})
```
# CROS
## jsonp
html
``` js
    <script>
      // 获取数据后，放入h1,插入body后
      function getData(data) {
        const showData = JSON.stringify(data);
        const h1 = document.createElement("h1");
        h1.innerHTML = `收到的消息是：${data.msg}`;
        document.body.appendChild(h1);
      }
    </script>
    <script src="http://localhost:8000/api/data?callback=getData"></script>
```
server.js
``` js
const http = require('http')

const server = http.createServer((request, response) => {
  let urlStr = request.url
  const urlObj = new URL(urlStr, 'http://localhost:8000')
  data = {
    msg: 'hello'
  }
  const params = urlObj.searchParams
  switch (urlObj.pathname) {
    case '/api/data':
      sendData = JSON.stringify(data)
      console.log(sendData, typeof sendData);
      response.write(`${params.get('callback')}(${sendData})`)
      break;
    default:
      response.write('page not found')
  }
  response.end()
})

server.listen(8000, () => {
  console.log('监听8000端口');
})
```
## CORS
server.js
``` js
const http = require('http')

const server = http.createServer((request, response) => {
  let urlStr = request.url
  const urlObj = new URL(urlStr, 'http://localhost:8000')
  data = {
    msg: 'hello'
  }
  const params = urlObj.searchParams
  switch (urlObj.pathname) {
    case '/api/data':
      sendData = JSON.stringify(data)
      console.log(sendData, typeof sendData);
      response.write(`${params.get('callback')}(${sendData})`)
      break;
    default:
      response.write('page not found')
  }
  response.end()
})

server.listen(8000, () => {
  console.log('监听8000端口');
})
```
## middleware(http-proxy-middware)
使用别人的接口。
### 安装
``` js
$ npm i http-proxy-middleware -S
```
server.js
``` js
const http = require('http')
const { createProxyMiddleware } = require('http-proxy-middleware');

const server = http.createServer((request, response) => {
  url = request.url
  if (/\/api/.test(url)) {
    const options = {
      target: 'https://srv.buysellads.com',
      changeOrigin: true,
      pathRewrite: { // 将/api改成其他地址
        '^/api': ''
      }
    }
    const proxy = createProxyMiddleware('/api', options)
    //代理：当遇到/api时，会将之前的地址，换为target的地址。
    proxy(request, response)
  } else {
    console.log('error')
  }
})
```
## 爬虫
cheerio
``` js
$ npm install cheerio
```
server.js
``` js
const http = require('http');
const https = require('https');
const log = require('../../utils/log')
const cheerio = require('cheerio');


function filterData(data) {
  // 转换为虚拟dom
  const $ = cheerio.load(data)
  const info = []
  // 通过对虚拟dom的元素进行抓取获取标签内容
  $('li.nav-item div.item-children ul.children-list div.title').each((index, el) => {
    console.log($(el).text())
    info.push({
      index,
      el: $(el).text()
    })
  })
  log.info(info)
}
const server = http.createServer((request, response) => {
  let data = ''
  https.get('https://www.mi.com/', (res) => {
    res.on('data', (chunk) => {
      data += chunk
    })
    res.on('end', () => {
      filterData(data)
      response.write(data)
      response.end('hello crawler')
    })
  })
})
```