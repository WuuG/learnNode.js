# 1. Node.js项目
## 1.1. Fronend
+ webpack
+ sass
+ JS库：Jquery --> vue
+ SPA：single page application（单页面应用）,路由：SME-Router
+ JS模块化：ES Module， commonjs Module
+ UI 组件库：Boostrap（AdminLTE） --> element

## 1.2. Backend
+ Node.js
+ Express
+ MongoDB(Mongoose)
## 1.3. 开发架构
前后端分离的架构
# 2. 前端
## 2.1. sidebar动态渲染的问题
需要注意的一件事是，template并不是事实存在的，所以可以利用其进行vfor的使用,也正是因为他虚拟存在的，所以要将key的绑定，绑定到事实存在的元素上。

同时，这样做的另一个好处是，不会破坏掉所使用组件的层次关系。也就是el-submenu的子元素一定是el-submenu或者el-menu-item
``` html
<!-- 使用v-for进行循环 -->
<template v-for="item in menuItems">
  <!-- 使用template 进行条件判断 -->
  <template v-if="item.sub">
    <!-- 对事实元素进行绑定 -->
    <el-submenu :index="item.index" :key="item.id">
      <template slot="title">
        <i class="el-icon-location"></i>
        <span slot="title">导航一</span>
      </template>
      <template v-for="subitem in item.sub">
        <el-menu-item :index="subitem.index" :key="subitem.id">
          <span slot="title">
            <i :class="subitem.icon"></i>
            {{ subitem.title }}
          </span>
        </el-menu-item>
      </template>
    </el-submenu>
  </template>
  <template v-else>
    <el-menu-item :index="item.index" :key="item.id">
      <i class="el-icon-menu"></i>
      <template v-slot:title>{{ item.title }}</template>
    </el-menu-item>
  </template>
</template>
```
# 3. 后端
## 3.1. 密码加密
工具：[bcrypt](https://www.npmjs.com/package/bcrypt)
### 3.1.1. 封装
``` js
const bcrypt = require('bcrypt');

const hash = (myPlaintextPassword, saltRounds = 10) => {
  return new Promise((resolve, reject) => {
    bcrypt.hash(myPlaintextPassword, saltRounds, function (err, hash) {
      if (err) {
        reject(err)
      }
      resolve(hash)
    });
  });
}

module.exports = {
  hash
}
```
## 3.2. cors
工具：[cors](https://www.npmjs.com/package/cors)
``` js
var express = require('express')
var cors = require('cors')
var app = express()
 
app.use(cors())
 
app.get('/products/:id', function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for all origins!'})
})
 
app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})
```
## 3.3. Cookie and Token
维护登录状态,使用Cookies，Token

## 3.4. Cookie Session方案
### 3.4.1. 自己产生cookie
[randomstring](https://www.npmjs.com/package/randomstring)
产生随机字符串的第三方工具 tool.js
``` js
const randomstring = require('randomstring');

const generateRandomstring = () => {
  return randomstring.generate()
}
```
controller/user.js
``` js
      const sessionId = generateRandomstring()  //产生随机字符串
      res.set('Set-cookie', `sessionId=${sessionId}; Path=/; HttpOnly`) //设置cookie
```
### 3.4.2. 工具产生cookie
[cookie-session](https://www.npmjs.com/package/cookie-session) 挂载中间件

app.js
``` js
var cookieSession = require('cookie-session')

// 设置cookie-session ,使用中间件后会在req中产生一个session对象
app.use(cookieSession({
  name: 'session',
  keys: ['key1', 'key2']
}))
```
使用中间件 controller/user.js
``` js
      // 访问req.sessoin来使用
      req.session.username = username
```
添加auth判断  auth.js
``` js
const auth = (req, res, next) => {
  if (req.session.username) {
    // 只有在用户登录后，保存下其用户名，才能进行下一步操作
    next()
  } else {
    res.render('fail', {
      data: JSON.stringify({
        message: '请登录'
      })
    })
  }
}

module.exports = {
  auth
}
```
在router中使用auth user.js
``` js
// 将auth放在list前，只有通过auth验证，才能进入list的路由
router.get('/', auth, list)
```
## 3.5. ToKen方案
后端发Token，前端存Token  后端验证Token
### 3.5.1. JWT
jsonwebtoken
``` js
$ npm install jsonwebtoken
```
### 3.5.2. 对称加密
通过JWT进行对称加密
``` js
var jwt = require('jsonwebtoken');
  // 1.对称加密
  const toKen = jwt.sign({ username: 'wuug' }, 'wuug')
  const decoded = jwt.verify(toKen, 'wuug')
```
### 3.5.3. 非对称加密
密钥生成的命令
``` js
// 打开命令台
openssl 
// 生成 RSA 私钥（无加密）
openssl genrsa -out rsa_private.key 2048
// 根据私钥 生成公钥
openssl rsa -in rsa_private.key -pubout -out rsa_public.key
```
通过JWT进行非对称加密
``` js
const path = require('path');
const fs = require('fs');
var jwt = require('jsonwebtoken');

  // 2.非对称加密
  // 私钥加密后发出token
  const privateKey = fs.readFileSync(path.resolve(__dirname, '../keys/rsa_private.key'))
  const token = jwt.sign({ username: 'wuug' }, privateKey, { algorithm: 'RS256' })
  // 收到toKen后 通过公钥验证
  const publicKey = fs.readFileSync(path.resolve(__dirname, '../keys/rsa_public.key'))
  const result = jwt.verify(token, publicKey)
```
### 3.6. 在项目中使用token
首先进行公钥私钥的生成，在上文中的[非对称加密](#非对称加密)中有提及。

在utils中添加加密和验证的方法 utils.js
``` js
const fs = require('fs');
const path = require('path');
const jwt = require('jsonwebtoken')

// 根据私钥生成token
const genToken = (payload) => {
  const privatrKeyPath = fs.readFileSync(path.resolve(__dirname, '../keys/rsa_private.key'))
  return jwt.sign(payload, privatrKeyPath, { algorithm: 'RS256' })
}
// 验证toKen
const vertifyToken = (token) => {
  const pubKeyPath = fs.readFileSync(path.resolve(__dirname, '../keys/rsa_private.key'))
  return jwt.verify(token, pubKeyPath, { algorithms: "RS256" })
}
```
controller/users.js
``` js
// 创建并通过自定义首部字段，传给用户
      const token = genToken({ username })
      // 自定义首部字段
      res.set('X-Access-Token', token).render('succ', {
        data: JSON.stringify({
          message: '成功登录！'
        })
      })


  // 通过获取自动逸首部字段，来进行token验证
    const token = req.get('X-Access-Token')
    vertifyToken(token)
    res.render('succ', {
      data: renderMessage(res, 'succ', '通过token验证')
    })
```
## 时间戳工具
[moment](https://www.npmjs.com/package/moment)