# Node.js项目
## Fronend
+ webpack
+ sass
+ JS库：Jquery --> vue
+ SPA：single page application（单页面应用）,路由：SME-Router
+ JS模块化：ES Module， commonjs Module
+ UI 组件库：Boostrap（AdminLTE） --> element

## Backend
+ Node.js
+ Express
+ MongoDB(Mongoose)
## 开发架构
前后端分离的架构
# 开发中遇到的问题
## 前端
### sidebar动态渲染的问题
需要注意的一件事是，template并不是事实存在的，所以可以利用其进行vfor的使用,也正是因为他虚拟存在的，所以要将key的绑定，绑定到事实存在的元素上。

同时，这样做的另一个好处是，不会破坏掉所使用组件的层次关系。也就是el-submenu的子元素一定是el-submenu或者el-menu-item
``` html
<!-- 使用v-for进行循环 -->
<template v-for="item in menuItems">
  <!-- 使用template 进行条件判断 -->
  <template v-if="item.sub">
    <!-- 对事实元素进行绑定 -->
    <el-submenu :index="item.index" :key="item.id">
      <template slot="title">
        <i class="el-icon-location"></i>
        <span slot="title">导航一</span>
      </template>
      <template v-for="subitem in item.sub">
        <el-menu-item :index="subitem.index" :key="subitem.id">
          <span slot="title">
            <i :class="subitem.icon"></i>
            {{ subitem.title }}
          </span>
        </el-menu-item>
      </template>
    </el-submenu>
  </template>
  <template v-else>
    <el-menu-item :index="item.index" :key="item.id">
      <i class="el-icon-menu"></i>
      <template v-slot:title>{{ item.title }}</template>
    </el-menu-item>
  </template>
</template>
```
## 后端
### 密码加密
工具：[bcrypt](https://www.npmjs.com/package/bcrypt)
#### 封装
``` js
const bcrypt = require('bcrypt');

const hash = (myPlaintextPassword, saltRounds = 10) => {
  return new Promise((resolve, reject) => {
    bcrypt.hash(myPlaintextPassword, saltRounds, function (err, hash) {
      if (err) {
        reject(err)
      }
      resolve(hash)
    });
  });
}

module.exports = {
  hash
}
```
### cors
工具：[cors](https://www.npmjs.com/package/cors)
#### 简单使用
``` js
var express = require('express')
var cors = require('cors')
var app = express()
 
app.use(cors())
 
app.get('/products/:id', function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for all origins!'})
})
 
app.listen(80, function () {
  console.log('CORS-enabled web server listening on port 80')
})
```
### Cookie and Token
维护登录状态,使用Cookies，Token

#### Cookie Session方案
#### 自己产生cookie
[randomstring](https://www.npmjs.com/package/randomstring)
产生随机字符串的第三方工具 tool.js
``` js
const randomstring = require('randomstring');

const generateRandomstring = () => {
  return randomstring.generate()
}
```
controller/user.js
``` js
      const sessionId = generateRandomstring()  //产生随机字符串
      res.set('Set-cookie', `sessionId=${sessionId}; Path=/; HttpOnly`) //设置cookie
```
#### 工具产生cookie
[cookie-session](https://www.npmjs.com/package/cookie-session) 挂载中间件

app.js
``` js
var cookieSession = require('cookie-session')

// 设置cookie-session ,使用中间件后会在req中产生一个session对象
app.use(cookieSession({
  name: 'session',
  keys: ['key1', 'key2']
}))
```
使用中间件 controller/user.js
``` js
      // 访问req.sessoin来使用
      req.session.username = username
```
添加auth判断  auth.js
``` js
const auth = (req, res, next) => {
  if (req.session.username) {
    // 只有在用户登录后，保存下其用户名，才能进行下一步操作
    next()
  } else {
    res.render('fail', {
      data: JSON.stringify({
        message: '请登录'
      })
    })
  }
}

module.exports = {
  auth
}
```
在router中使用auth user.js
``` js
// 将auth放在list前，只有通过auth验证，才能进入list的路由
router.get('/', auth, list)
```
#### ToKen方案
后端发Token，前端存Token  后端验证Token
##### JWT
jsonwebtoken
``` js
$ npm install jsonwebtoken
```
##### 对称加密
通过JWT进行对称加密
``` js
var jwt = require('jsonwebtoken');
  // 1.对称加密
  const toKen = jwt.sign({ username: 'wuug' }, 'wuug')
  const decoded = jwt.verify(toKen, 'wuug')
```
###### 非对称加密
密钥生成的命令
``` js
// 打开命令台
openssl 
// 生成 RSA 私钥（无加密）
openssl genrsa -out rsa_private.key 2048
// 根据私钥 生成公钥
openssl rsa -in rsa_private.key -pubout -out rsa_public.key
```
通过JWT进行非对称加密
``` js
const path = require('path');
const fs = require('fs');
var jwt = require('jsonwebtoken');

  // 2.非对称加密
  // 私钥加密后发出token
  const privateKey = fs.readFileSync(path.resolve(__dirname, '../keys/rsa_private.key'))
  const token = jwt.sign({ username: 'wuug' }, privateKey, { algorithm: 'RS256' })
  // 收到toKen后 通过公钥验证
  const publicKey = fs.readFileSync(path.resolve(__dirname, '../keys/rsa_public.key'))
  const result = jwt.verify(token, publicKey)
```